<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>王浩的小课桌</title>
    <link>http://sakyawang.github.io</link>
    <pubDate>27 Oct 17 10:24 CST</pubDate>
    <item>
      <title>面向对象设计基本原则</title>
      <link>http://sakyawang.github.io/设计模式/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>2017-10-27 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;面向对象设计原则SOLID&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;参考：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design&#34;&gt;https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html&#34;&gt;http://www.cnblogs.com/hellojava/archive/2013/03/18/2966684.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;1. S – Single Responsibility Principle 职责单一原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对象应该仅具有一种单一功能。&#xA;概念上和unix的设计原则 “Do one thing and do it well”很相似。听起来很简单但是实践起来很难。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;比如，现在有一些图形要计算所有图形的面积。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Circle {&#xA;&#xA;    private double radius;&#xA;&#xA;    public Circle Circle(double radius) {&#xA;        this.radius = radius;&#xA;    }&#xA;&#xA;    private double getRadius() {&#xA;    &#x9;return this.radius;&#xA;    }&#xA;}&#xA;&#xA;class Square {&#xA;&#xA;    private double length;&#xA;&#xA;    public Square(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;首先，创建图形类，包含构造函数和需要的属性参数。&#xA;接下来创建面积计算类AreaCalculator，然后编写方法计算提供的图形参数的面积总和。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AreaCalculator {&#xA;&#xA;    private List shapes;&#xA;&#xA;    public AreaCalculator(List shapes) {&#xA;        this.shapes = shapes;&#xA;    }&#xA;&#xA;    public double sum() {&#xA;        // logic to sum the areas&#xA;    }&#xA;&#xA;    public void output() {&#xA;        return System.out.println(String.format(&amp;quot;Sum of the areas of provided shapes: %s&amp;quot;, this.sum());&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;简单实例化AreaCalculator对象，然后传入一个图形集合，然后调用output方法显示面积总和。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AreaCalculator areaCalculator = new AreaCalculator(Arrays.asList(new Circle(10.0f), new Square(12.0f)));&#xA;areaCalculator.output()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里output方法的问题是AreaCalculator处理计算逻辑然后输出字符串结果。那么，如果用户想用json或者其他格式输出计算结果呢？&#xA;所有的操作都放到AreaCalculator中做违背了职责单一原则。AreaCalculator应该只计算提供的图形的面积总和，而不用关心如何输入结果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，需要新建一个SumCalculatorOutputter类用来处理统计结果输出操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SumCalculatorOutputter类如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SumCalculatorOutputter {&#xA;&#xA;&#x9;private AreaCalculator areaCalculator;&#xA;&#xA;&#x9;public SumCalculatorOutputter(AreaCalculator areaCalculator) {&#xA;&#x9;&#x9;this.areaCalculator = areaCalculator;&#xA;&#x9;}&#xA;&#xA;&#x9;public void outputJson() {&#xA;&#x9;&#x9;double sum = this.areaCalculator.sum();&#xA;&#x9;}&#xA;&#xA;&#x9;public void outputHtml() {&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public void outputString() {&#xA;&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;AreaCalculator areaCalculator = new AreaCalculator(Arrays.asList(new Circle(10.0f), new Square(12.0f)));&#xA;&#xA;SumCalculatorOutputter output = new SumCalculatorOutputter(areaCalculator);&#xA;output.outputJson();&#xA;output.outputHtml();&#xA;output.outputString();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在不管你要把结果按照何种方式输出都放在SumCalculatorOutputter中处理。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2. O – Open-Closed Principle 开放封闭原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对象应该是对于扩展开放的，但是对于修改封闭的。&#xA;这意味着一个类应该可以容易地扩展，而不需要修改类本身。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;我们来看下AreaCalculator类的sum方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public double sum() {&#xA;&#x9;double sum = 0.0f;&#xA;&#x9;for(Object shape : this.shapes) {&#xA;&#x9;&#x9;if(shape instanceof Circle) {&#xA;&#x9;&#x9;&#x9;Circle shape = (Circle)shape;&#xA;&#x9;&#x9;&#x9;sum += Math.pi * Math.sqrt(shape.getRadius());&#xA;&#x9;&#x9;} else if(shape instanceof Square) {&#xA;&#x9;&#x9;&#x9;Square shape = (Square)shape;&#xA;&#x9;&#x9;&#x9;sum += Math.sqrt(shape.getLength());&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return sum;&#xA;}   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果我们要支持更多的图形就需要添加更多的“else if”代码块儿，这就违背了开闭原则。&#xA;一种解决方式是把面积计算的逻辑迁移到图形类中，AreaCalculator类的sum方法调用图形类的面积计算方法。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Circle {&#xA;&#xA;    private double radius;&#xA;&#xA;    public Circle Circle(double radius) {&#xA;        this.radius = radius;&#xA;    }&#xA;&#xA;&#x9;public double area(){&#xA;&#x9;&#x9;return Math.PI * Math.sqrt(this.radius);&#xA;&#x9;}&#xA;&#xA;    private double getRadius() {&#xA;    &#x9;return this.radius;&#xA;    }&#xA;}&#xA;&#xA;class Square {&#xA;&#xA;    private double length;&#xA;&#xA;    public Square(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;public double area(){&#xA;&#x9;&#x9;return Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后我们抽取公共方法area作为接口ShapeInterface的方法，这样新增图形的时候只要实现ShapeInterface接口。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface ShapeInterface {&#xA;&#x9;double area();&#xA;}&#xA;&#xA;class Circle implements ShapeInterface {&#xA;&#xA;    private double radius;&#xA;&#xA;    public Circle Circle(double radius) {&#xA;        this.radius = radius;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area(){&#xA;&#x9;&#x9;return Math.PI * Math.sqrt(this.radius);&#xA;&#x9;}&#xA;&#xA;    private double getRadius() {&#xA;    &#x9;return this.radius;&#xA;    }&#xA;}&#xA;&#xA;class Square implements ShapeInterface {&#xA;&#xA;    private double length;&#xA;&#xA;    public Square(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area(){&#xA;&#x9;&#x9;return Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;现在修改AreaCalculator类的sum方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AreaCalculator {&#xA;&#xA;    private List&amp;lt;ShapeInterface&amp;gt; shapes;&#xA;&#xA;    public AreaCalculator(List&amp;lt;ShapeInterface&amp;gt; shapes) {&#xA;        this.shapes = shapes;&#xA;    }&#xA;&#xA;    public double sum() {&#xA;    &#x9;return this.shapes.stream.map(ShapeInterface::sum).mapToDouble(Double::doubleValue).sum();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;3. L – Liskov Substitution Principle 里氏替换原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;子类可以扩展父类的功能，但不能改变父类原有的功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;子类中可以增加自己特有的方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;违背里氏替换原则的例子，我们新增一个体积计算器类VolumeCalculator继承面积计算器类，覆盖sum方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class VolumeCalculator extends AreaCalulator {&#xA;&#xA;    public VolumeCalculator(List&amp;lt;ShapeInterface&amp;gt; shapes) {&#xA;        super(shapes);&#xA;    }&#xA;&#xA;&#x9;@override&#xA;    public double sum() {&#xA;        // 新增其他逻辑操作变为体积统计&#xA;        return this.shapes.stream.map(ShapeInterface::sum).mapToDouble(Double::doubleValue).sum();&#xA;    }&#xA;&#xA;}    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;遵循里氏替换原则的例子如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class VolumeCalculator extends AreaCalulator {&#xA;&#xA;    public VolumeCalculator(List&amp;lt;ShapeInterface&amp;gt; shapes) {&#xA;        super(shapes);&#xA;    }&#xA;&#xA;&#x9;/**&#xA;&#x9; * 新增体积统计方法&#xA;&#x9; */&#xA;    public double volume() {&#xA;    &#x9;return 0.0d;&#xA;    }&#xA;&#xA;}    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;4. I – Interface Segregation Principle 接口隔离原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;多个特定客户端接口要好于一个宽泛用途的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端不应该强行依赖它不需要的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类间的依赖关系应该建立在最小的接口上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;客户端不应该依赖它不需要的接口，意思就是说客户端只要依赖它需要的接口，它需要什么接口，就提供什么接口，不提供多余的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;“类间的依赖关系应该建立在最小的接口上”也表达这一层意思。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通俗的讲就是：接口中的方法应该尽量少，不要使接口过于臃肿，不要有很多不相关的逻辑方法。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;我们继续以形状举例，形状有立体形状所以给形状接口ShapeInterface提供体积计算方法volume：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface ShapeInterface {&#xA;&#x9;double area();&#xA;&#x9;double volume();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;所有实现ShapeInterface接口的形状类都要实现volume方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Circle implements ShapeInterface {&#xA;&#xA;    private double radius;&#xA;&#xA;    public Circle Circle(double radius) {&#xA;        this.radius = radius;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return Math.PI * Math.sqrt(this.radius);&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;@override&#xA;&#x9;public double volume() {&#xA;&#x9;&#x9;return 0.0d;&#xA;&#x9;}&#xA;&#xA;    private double getRadius() {&#xA;    &#x9;return this.radius;&#xA;    }&#xA;}&#xA;&#xA;class Square implements ShapeInterface {&#xA;&#xA;    private double length;&#xA;&#xA;    public Square(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;@override&#xA;&#x9;public double volume() {&#xA;&#x9;&#x9;return 0.0d;&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&#xA;class Cube implements ShapeInterface {&#xA;&#xA;    private double length;&#xA;&#xA;    public Cube(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return 6 * Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;@override&#xA;&#x9;public double volume() {&#xA;&#x9;&#x9;return Math.pow(this.length, 3);&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这么做会导致Circle和Square这样的平面图形必须要实现一个不必要的volume方法。&#xA;可以提供一个立体形状接口SolidShapeInterface，提供volume供立体形状来实现：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface ShapeInterface {&#xA;&#x9;double area();&#xA;}&#xA;&#xA;interface SolidShapeInterface {&#xA;&#x9;double volume();&#xA;}&#xA;&#xA;class Circle implements ShapeInterface {&#xA;&#xA;    private double radius;&#xA;&#xA;    public Circle Circle(double radius) {&#xA;        this.radius = radius;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return Math.PI * Math.sqrt(this.radius);&#xA;&#x9;}&#xA;&#xA;    private double getRadius() {&#xA;    &#x9;return this.radius;&#xA;    }&#xA;}&#xA;&#xA;class Square implements ShapeInterface {&#xA;&#xA;    private double length;&#xA;&#xA;    public Square(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&#xA;class Cube implements ShapeInterface, SolidShapeInterface {&#xA;&#xA;    private double length;&#xA;&#xA;    public Cube(double length) {&#xA;        this.length = length;&#xA;    }&#xA;&#xA;&#x9;@override&#xA;&#x9;public double area() {&#xA;&#x9;&#x9;return 6 * Math.sqrt(this.length);&#xA;&#x9;}&#xA;&#xA;&#x9;@override&#xA;&#x9;public double volume() {&#xA;&#x9;&#x9;return Math.pow(this.length, 3);&#xA;&#x9;}&#xA;&#xA;&#x9;public double getLength() {&#xA;&#x9;&#x9;return this.length;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;5. D – Dependency Inversion Principle 依赖倒置原则&lt;/h3&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一个方法应该遵从“依赖于抽象而不是一个实例”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;抽象不应该依赖细节；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;细节应该依赖抽象。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;抽象：即抽象类或接口，两者是不能够实例化的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类A直接依赖于类B，假如要将类A修改为依赖类C，则必须通过修改类A的代码来达成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这种场景下，类A一般是高层模块，负责复杂的业务逻辑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;类B和C是底层模块，负责基本的原子操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;假如修改类A，将会给程序带来不必要的风险。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而遵循依赖倒置原则的程序设计可以解决这一问题。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;下面以代码示例说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//具体Jim人类&#xA;public class Jim {&#xA;    public void eat(Apple apple){&#xA;        System.out.println(&amp;quot;Jim eat &amp;quot; + apple.getName());&#xA;    }&#xA;}&#xA;//具体苹果类&#xA;public class Apple {&#xA;    public String getName(){&#xA;        return &amp;quot;apple&amp;quot;;&#xA;    }&#xA;}&#xA;public class Client {&#xA;    public static void main(String[] args) {&#xA;        Jim jim = new Jim();&#xA;        Apple apple = new Apple();&#xA;        jim.eat(apple);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面代码看起来比较简单，但其实是一个非常脆弱的设计。现在Jim可以吃苹果了，但是不能只吃苹果而不吃别的水果啊，这样下去肯定会造成营养失衡。现在想让Jim吃香蕉了（好像香蕉里含钾元素比较多，吃点比较有益），突然发现Jim是吃不了香蕉的，那怎么办呢？看来只有修改代码了啊，由于上面代码中Jim类依赖于Apple类，所以导致不得不去改动Jim类里面的代码。那如果下次Jim又要吃别的水果了呢？继续修改代码？这种处理方式显然是不可取的，频繁修改会带来很大的系统风险，改着改着可能就发现Jim不会吃水果了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上面的代码之所以会出现上述难堪的问题，就是因为Jim类依赖于Apple类，两者是紧耦合的关系，其导致的结果就是系统的可维护性大大降低。要增加香蕉类却要去修改Jim类代码，这是不可忍受的，你改你的代码为什么要动我的啊，显然Jim不乐意了。我们常说要设计一个健壮稳定的系统，而这里只是增加了一个香蕉类，就要去修改Jim类，健壮和稳定还从何谈起。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而根据依赖倒置原则，我们可以对上述代码做些修改，提取抽象的部分。首先我们提取出两个接口：People和Fruit，都提供各自必需的抽象方法，这样以后无论是增加Jim人类，还是增加Apple、Banana等各种水果，都只需要增加自己的实现类就可以了。由于遵循依赖倒置原则，只依赖于抽象，而不依赖于细节，所以增加类无需修改其他类。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//人接口&#xA;public interface People {&#xA;    public void eat(Fruit fruit);//人都有吃的方法，不然都饿死了&#xA;}&#xA;//水果接口&#xA;public interface Fruit {&#xA;    public String getName();//水果都是有名字的&#xA;}&#xA;//具体Jim人类&#xA;public class Jim implements People{&#xA;    public void eat(Fruit fruit){&#xA;        System.out.println(&amp;quot;Jim eat &amp;quot; + fruit.getName());&#xA;    }&#xA;}&#xA;//具体苹果类&#xA;public class Apple implements Fruit{&#xA;    public String getName(){&#xA;        return &amp;quot;apple&amp;quot;;&#xA;    }&#xA;}&#xA;//具体香蕉类&#xA;public class Banana implements Fruit{&#xA;    public String getName(){&#xA;        return &amp;quot;banana&amp;quot;;&#xA;    }&#xA;}&#xA;public class Client {&#xA;    public static void main(String[] args) {&#xA;        People jim = new Jim();&#xA;        Fruit apple = new Apple();&#xA;        Fruit Banana = new Banana();//这里符合了里氏替换原则&#xA;        jim.eat(apple);&#xA;        jim.eat(Banana);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;People类是复杂的业务逻辑，属于高层模块，而Fruit是原子模块，属于低层模块。People依赖于抽象的Fruit接口，这就做到了：高层模块不应该依赖低层模块，两者都应该依赖于抽象（抽象类或接口）。&lt;/li&gt;&#xA;&lt;li&gt;Pople和Fruit接口与各自的实现类没有关系，增加实现类不会影响接口，这就做到了：抽象（抽象类或接口）不应该依赖于细节（具体实现类）。&lt;/li&gt;&#xA;&lt;li&gt;Jim、Apple、Banana实现类都要去实现各自的接口所定义的抽象方法，所以是依赖于接口的。这就做到了：细节（具体实现类）应该依赖抽象。&#xA;通过上面的代码段我们可以看到，高级和低级模块都取决于抽象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;到了这里，我们对依赖倒置原则的“依赖”就很好理解了，但是什么是“倒置”呢。是这样子的，刚开始按照正常人的一般思维方式，我想吃香蕉就是吃香蕉，想吃苹果就吃苹果，编程也是这样，都是按照面向实现的思维方式来设计。而现在要倒置思维，提取公共的抽象，面向接口（抽象类）编程。不再依赖于具体实现了，而是依赖于接口或抽象类，这就是依赖的思维方式“倒置”了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;依赖倒置常用的三种实现方式：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;依赖接口作为参数使用&lt;/li&gt;&#xA;&lt;li&gt;依赖接口通过构造函数传递&lt;/li&gt;&#xA;&lt;li&gt;依赖接口通过setter方法传递&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;总结&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;面向对象设计的这五条基本原则是设计模式和重构的基础。&#xA;只有充分理解这五条原则才能更好的理解设计模式的思想，更好的进行代码的重构。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>rpc</title>
      <link>http://sakyawang.github.io/java/rpc/</link>
      <pubDate>2017-05-11 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;基于jdk序列化和tcp的rpc调用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;RPC调用图&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/rpc.png&#34; width = &#34;800&#34; height = &#34;400&#34; alt=&#34;rpc&#34; align=center /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、2和服务注册未实现&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;文件说明&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AbstractService 抽象服务类&#xA;RpcRequest      服务请求对象&#xA;RpcResponse     服务返回结果对象&#xA;&#xA;RpcClient       rpc客户端&#xA;RpcServer       rpc服务端&#xA;&#xA;UserService     用户服务&#xA;User            用户对象&#xA;UserParam       用户参数对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;代码展示&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;AbstractService&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class AbstractService&amp;lt;T extends RpcRequest, F extends RpcResponse&amp;gt; implements Serializable {&#xA;&#xA;    public abstract F execute(T request);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RpcRequest&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class RpcRequest&amp;lt;T extends Serializable&amp;gt; implements Serializable{&#xA;&#xA;    private T params;&#xA;&#xA;    public T getParams() {&#xA;        return params;&#xA;    }&#xA;&#xA;    public void setParams(T params) {&#xA;        this.params = params;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RpcResponse&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class RpcResponse&amp;lt;T extends Serializable&amp;gt; implements Serializable {&#xA;&#xA;    private int code = 200;&#xA;&#xA;    private String message = &amp;quot;success&amp;quot;;&#xA;&#xA;    private T result;&#xA;&#xA;    public int getCode() {&#xA;        return code;&#xA;    }&#xA;&#xA;    public void setCode(int code) {&#xA;        this.code = code;&#xA;    }&#xA;&#xA;    public String getMessage() {&#xA;        return message;&#xA;    }&#xA;&#xA;    public void setMessage(String message) {&#xA;        this.message = message;&#xA;    }&#xA;&#xA;    public T getResult() {&#xA;        return result;&#xA;    }&#xA;&#xA;    public void setResult(T result) {&#xA;        this.result = result;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;UserService&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class UserService extends AbstractService&amp;lt;RpcRequest&amp;lt;UserParam&amp;gt;,RpcResponse&amp;lt;User&amp;gt;&amp;gt; {&#xA;&#xA;    @Override&#xA;    public RpcResponse&amp;lt;User&amp;gt; execute(RpcRequest&amp;lt;UserParam&amp;gt; request) {&#xA;        UserParam params = request.getParams();&#xA;        String name = params.getName();&#xA;        RpcResponse&amp;lt;User&amp;gt; response = new RpcResponse&amp;lt;&amp;gt;();&#xA;        User user = new User();&#xA;        if (&amp;quot;wanghao&amp;quot;.equals(name)) {&#xA;            user.setName(&amp;quot;wanghao&amp;quot;);&#xA;            user.setAge(29);&#xA;            response.setResult(user);&#xA;        } else {&#xA;            response.setCode(-200);&#xA;            response.setMessage(&amp;quot;no the user&amp;quot;);&#xA;        }&#xA;        return response;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;User&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class User implements Serializable {&#xA;&#xA;    private String name;&#xA;&#xA;    private int age;&#xA;&#xA;    public String getName() {&#xA;        return name;&#xA;    }&#xA;&#xA;    public void setName(String name) {&#xA;        this.name = name;&#xA;    }&#xA;&#xA;    public int getAge() {&#xA;        return age;&#xA;    }&#xA;&#xA;    public void setAge(int age) {&#xA;        this.age = age;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;UserParam&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class UserParam implements Serializable {&#xA;&#xA;    private String name;&#xA;&#xA;    public String getName() {&#xA;        return name;&#xA;    }&#xA;&#xA;    public void setName(String name) {&#xA;        this.name = name;&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RpcClient&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class RpcClient {&#xA;&#xA;    public static void main(String[] args) throws IOException, ClassNotFoundException {&#xA;        Socket socket = new Socket(&amp;quot;10.2.6.20&amp;quot;, 8888);&#xA;        OutputStream outputStream = socket.getOutputStream();&#xA;        ObjectOutputStream stream = new ObjectOutputStream(outputStream);&#xA;        RpcRequest&amp;lt;UserParam&amp;gt; request = new RpcRequest&amp;lt;&amp;gt;();&#xA;        UserParam param = new UserParam();&#xA;        param.setName(&amp;quot;sakyawang&amp;quot;);&#xA;        request.setParams(param);&#xA;        stream.writeObject(request);&#xA;        stream.flush();&#xA;        InputStream inputStream = socket.getInputStream();&#xA;        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);&#xA;        RpcResponse&amp;lt;User&amp;gt; response = (RpcResponse&amp;lt;User&amp;gt;) objectInputStream.readObject();&#xA;        System.out.println(response.getMessage());&#xA;        System.out.println(response.getResult().getAge());&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RpcServer&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class RpcServer {&#xA;&#xA;    public static void main(String[] args) throws IOException, ClassNotFoundException {&#xA;        ServerSocket serverSocket = new ServerSocket();&#xA;        serverSocket.bind(new InetSocketAddress(8888));&#xA;        Socket socket = serverSocket.accept();&#xA;        InputStream inputStream = socket.getInputStream();&#xA;        OutputStream outputStream = socket.getOutputStream();&#xA;        ObjectInputStream stream = new ObjectInputStream(inputStream);&#xA;        RpcRequest&amp;lt;UserParam&amp;gt; request = (RpcRequest&amp;lt;UserParam&amp;gt;) stream.readObject();&#xA;        UserService userService = new UserService();&#xA;        RpcResponse&amp;lt;User&amp;gt; response = userService.execute(request);&#xA;        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);&#xA;        objectOutputStream.writeObject(response);&#xA;        objectOutputStream.flush();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>nginx-start</title>
      <link>http://sakyawang.github.io/nginx/nginx-start/</link>
      <pubDate>2017-05-10 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;centos7下yum安装nginx并配置开机启动&lt;/h1&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;新增yum源&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/etc/yum.repo.d下新建nginx.repo&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[nginx]&#xA;name=nginx repo&#xA;baseurl=http://nginx.org/packages/centos/7/$basearch/&#xA;gpgcheck=0&#xA;enabled=1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo yum install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/&#34;&gt;官网配置&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;vim /etc/init.d/nginx&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;#&#xA;# nginx - this script starts and stops the nginx daemon&#xA;#&#xA;# chkconfig:   - 85 15&#xA;# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \&#xA;#               proxy and IMAP/POP3 proxy server&#xA;# processname: nginx&#xA;# config:      /etc/nginx/nginx.conf&#xA;# config:      /etc/sysconfig/nginx&#xA;# pidfile:     /var/run/nginx.pid&#xA;&#xA;# Source function library.&#xA;. /etc/rc.d/init.d/functions&#xA;&#xA;# Source networking configuration.&#xA;. /etc/sysconfig/network&#xA;&#xA;# Check that networking is up.&#xA;[ &amp;quot;$NETWORKING&amp;quot; = &amp;quot;no&amp;quot; ] &amp;amp;&amp;amp; exit 0&#xA;&#xA;nginx=&amp;quot;/usr/sbin/nginx&amp;quot;&#xA;prog=$(basename $nginx)&#xA;&#xA;NGINX_CONF_FILE=&amp;quot;/etc/nginx/nginx.conf&amp;quot;&#xA;&#xA;[ -f /etc/sysconfig/nginx ] &amp;amp;&amp;amp; . /etc/sysconfig/nginx&#xA;&#xA;lockfile=/var/lock/subsys/nginx&#xA;&#xA;make_dirs() {&#xA;   # make required directories&#xA;   user=`$nginx -V 2&amp;gt;&amp;amp;1 | grep &amp;quot;configure arguments:.*--user=&amp;quot; | sed &#39;s/[^*]*--user=\([^ ]*\).*/\1/g&#39; -`&#xA;   if [ -n &amp;quot;$user&amp;quot; ]; then&#xA;      if [ -z &amp;quot;`grep $user /etc/passwd`&amp;quot; ]; then&#xA;         useradd -M -s /bin/nologin $user&#xA;      fi&#xA;      options=`$nginx -V 2&amp;gt;&amp;amp;1 | grep &#39;configure arguments:&#39;`&#xA;      for opt in $options; do&#xA;          if [ `echo $opt | grep &#39;.*-temp-path&#39;` ]; then&#xA;              value=`echo $opt | cut -d &amp;quot;=&amp;quot; -f 2`&#xA;              if [ ! -d &amp;quot;$value&amp;quot; ]; then&#xA;                  # echo &amp;quot;creating&amp;quot; $value&#xA;                  mkdir -p $value &amp;amp;&amp;amp; chown -R $user $value&#xA;              fi&#xA;          fi&#xA;       done&#xA;    fi&#xA;}&#xA;&#xA;start() {&#xA;    [ -x $nginx ] || exit 5&#xA;    [ -f $NGINX_CONF_FILE ] || exit 6&#xA;    make_dirs&#xA;    echo -n $&amp;quot;Starting $prog: &amp;quot;&#xA;    daemon $nginx -c $NGINX_CONF_FILE&#xA;    retval=$?&#xA;    echo&#xA;    [ $retval -eq 0 ] &amp;amp;&amp;amp; touch $lockfile&#xA;    return $retval&#xA;}&#xA;&#xA;stop() {&#xA;    echo -n $&amp;quot;Stopping $prog: &amp;quot;&#xA;    killproc $prog -QUIT&#xA;    retval=$?&#xA;    echo&#xA;    [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile&#xA;    return $retval&#xA;}&#xA;&#xA;restart() {&#xA;    configtest || return $?&#xA;    stop&#xA;    sleep 1&#xA;    start&#xA;}&#xA;&#xA;reload() {&#xA;    configtest || return $?&#xA;    echo -n $&amp;quot;Reloading $prog: &amp;quot;&#xA;    killproc $nginx -HUP&#xA;    RETVAL=$?&#xA;    echo&#xA;}&#xA;&#xA;force_reload() {&#xA;    restart&#xA;}&#xA;&#xA;configtest() {&#xA;  $nginx -t -c $NGINX_CONF_FILE&#xA;}&#xA;&#xA;rh_status() {&#xA;    status $prog&#xA;}&#xA;&#xA;rh_status_q() {&#xA;    rh_status &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&#xA;}&#xA;&#xA;case &amp;quot;$1&amp;quot; in&#xA;    start)&#xA;        rh_status_q &amp;amp;&amp;amp; exit 0&#xA;        $1&#xA;        ;;&#xA;    stop)&#xA;        rh_status_q || exit 0&#xA;        $1&#xA;        ;;&#xA;    restart|configtest)&#xA;        $1&#xA;        ;;&#xA;    reload)&#xA;        rh_status_q || exit 7&#xA;        $1&#xA;        ;;&#xA;    force-reload)&#xA;        force_reload&#xA;        ;;&#xA;    status)&#xA;        rh_status&#xA;        ;;&#xA;    condrestart|try-restart)&#xA;        rh_status_q || exit 0&#xA;            ;;&#xA;    *)&#xA;        echo $&amp;quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&amp;quot;&#xA;        exit 2&#xA;esac&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置文件执行权限&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;chmod a+x /etc/init.d/nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;加入chkconfig管理列表&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;chkconfig --add /etc/init.d/nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;开机启动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;chkconfig nginx on&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;启动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;service nginx start&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;遇到的问题&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;非nginx目录下项目访问403&lt;/p&gt;&#xA;&#xA;&lt;p&gt;fix: nginx.conf 修改启动用户为 root  root&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;启动报错selinux&lt;/p&gt;&#xA;&#xA;&lt;p&gt;fix: /var/cache/nginx清理&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>nexus</title>
      <link>http://sakyawang.github.io/nexus/nexus/</link>
      <pubDate>2017-05-10 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;nexnus搭建maven私服配置导包&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;安装配置&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;下载安装包&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo wget https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.3.1-01-unix.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装运行&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tar zxvf nexus-3.3.1-01-unix.tar.gz &#xA;cd nexus-3.3.1-01/      &#xA;nohup ./nexus run&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;maven setting.xml配置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;servers&amp;gt;&#xA;    &amp;lt;server&amp;gt;  &#xA;        &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;  &#xA;        &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;  &#xA;        &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;  &#xA;    &amp;lt;/server&amp;gt;  &#xA;&amp;lt;/servers&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;pom.xml配置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;&#xA;        &amp;lt;repository&amp;gt;&#xA;            &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;&#xA;            &amp;lt;name&amp;gt;Team Nexus Repository&amp;lt;/name&amp;gt;&#xA;            &amp;lt;url&amp;gt;http://10.2.6.1:8081/repository/maven-public/&amp;lt;/url&amp;gt;&#xA;        &amp;lt;/repository&amp;gt;&#xA;    &amp;lt;/repositories&amp;gt;&#xA;&#xA;&amp;lt;pluginRepositories&amp;gt;&#xA;    &amp;lt;pluginRepository&amp;gt;&#xA;        &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;&#xA;        &amp;lt;name&amp;gt;Team Nexus Repository&amp;lt;/name&amp;gt;&#xA;        &amp;lt;url&amp;gt;http://10.2.6.1:8081/repository/maven-public/&amp;lt;/url&amp;gt;&#xA;    &amp;lt;/pluginRepository&amp;gt;&#xA;&amp;lt;/pluginRepositories&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;mvn deploy使用&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mvn deploy:deploy-file -DgroupId=${groupId} -DartifactId=${artifactId} -Dversion=${version} -Dpackaging=jar -Dfile=${path/*.jar} -Durl=http://10.2.6.1:8081/repository/thirdparty/ -DrepositoryId=nexus &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Centos7 安装配置elasticsearch-head</title>
      <link>http://sakyawang.github.io/nodejs/Centos7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEelasticsearch-head/</link>
      <pubDate>2017-05-10 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Centos7 安装配置elasticsearch-head&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;安装nodejs&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;配置yum源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl --silent --location https://rpm.nodesource.com/setup_7.x | bash -&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装nodejs和npm&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;yum install -y nodejs&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;配置淘宝npm镜像&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;通过config命令&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org &#xA;npm info underscore （如果上面配置正确这个命令会有字符串response）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;命令行指定&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;npm --registry https://registry.npm.taobao.org info underscore &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;编辑 ~/.npmrc 加入下面内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;registry = https://registry.npm.taobao.org&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;安装phantomjs（elasticsearch-head依赖）&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2&#34;&gt;下载&lt;/a&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装配置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;tar xvf phantomjs-2.1.1-linux-x86_64.tar.bz2&#xA;export PHANTOMJS_HOME=/path/phantomjs/bin&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;安装配置运行elasticsearch-head&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/mobz/elasticsearch-head.git&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;npm install&#xA;&#xA;vim ./_site/app.js&#xA;app.App = ui.AbstractWidget.extend({&#xA;        defaults: {&#xA;                base_uri: &amp;quot;http://10.2.6.2:9200&amp;quot;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;运行访问&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;npm run start&#xA;http://10.2.6.2:9100&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>centos7 lvs扩容</title>
      <link>http://sakyawang.github.io/linux/centos7-lvs%E6%89%A9%E5%AE%B9/</link>
      <pubDate>2017-05-05 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;centos7 lvs扩容&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;创建新分区&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fdisk -l        //查看可用硬盘(如：sda)&#xA;fdisk /dev/sda  &#xA;n               //新增分区&#xA;w               //保存操作&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;修改分区格式为lvm&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fdisk /dev/sda&#xA;t               //修改分区类型&#xA;L               //显示分区类型表&#xA;8e              //修改分区类型为lvm&#xA;w               //保存修改&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建物理卷&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pvcreate /dev/sda3 //创建物理卷sda3,最好重启一下&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;centos卷组扩展&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pvs                         //查看物理卷列表&#xA;vgs                         //查看卷组列表&#xA;vgextend centos /dev/sda3   //centos卷组追加/dev/sda3物理卷&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;逻辑卷扩展&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lvs                                         //逻辑卷列表&#xA;lvextend -L +30G /dev/mapper/centos-root    //逻辑卷扩展大小 &#xA;lvscan            //List all logical volumes in all volume groups&#xA;xfs_growfs /dev/mapper/centos-root          //扩展xfs文件系统大小&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>alibaba-java</title>
      <link>http://sakyawang.github.io/java/alibaba-java/</link>
      <pubDate>2017-03-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;根据&lt;a href=&#34;https://yq.aliyun.com/attachment/download/?id=1170&#34;&gt;阿里巴巴java开发手册.pdf&lt;/a&gt;转化。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;一、编程规约&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;(一)  命名规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】  代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： _name / _&lt;em&gt;name / $Object / name&lt;/em&gt; / name$ / Object$&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】  代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int  某变量  = 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： alibaba / taobao / youku / hangzhou  等国际通用的名称，可视同英文。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： localValue / getHttpMessage() / inputUserId&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： MAX_STOCK_COUNT&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： MAX_COUNT&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】中括号是数组类型的一部分，数组定义如下：String[] args;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：使用 String args[]的方式来定义。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：定义为基本数据类型 Boolean  isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候， “以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】杜绝完全不规范的缩写，避免望文不知义。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：  AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成  condi，此类随意缩写严重降低了代码的可阅读性。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class OrderFactory;&#xA;public class LoginProxy;&#xA;public class ResourceObserver;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】接口类中的方法和属性不要加任何修饰符号（public  也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：接口方法签名：void f();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接口基础常量表示：String COMPANY = &amp;ldquo;alibaba&amp;rdquo;;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：接口方法定义：public abstract void f();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;接口和实现类的命名有两套规则：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：CacheServiceImpl 实现 CacheService 接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名 （通常是–able 的形式） 。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：AbstractTranslator 实现  Translatable。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】各层命名规约：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A) Service/DAO 层方法命名规约&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  获取单个对象的方法用 get 做前缀。&#xA;2）  获取多个对象的方法用 list 做前缀。&#xA;3）  获取统计值的方法用 count 做前缀。&#xA;4）  插入的方法用 save（推荐）或 insert 做前缀。&#xA;5）  删除的方法用 remove（推荐）或 delete 做前缀。&#xA;6）  修改的方法用 update 做前缀。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;B)  领域模型命名规约&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  数据对象：xxxDO，xxx 即为数据表名。&#xA;2）  数据传输对象：xxxDTO，xxx 为业务领域相关的名称。&#xA;3）  展示对象：xxxVO，xxx 一般为网页名称。&#xA;4）  POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(二)  常量定义&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;String key = &amp;quot;Id#taobao_&amp;quot;+tradeId；&#xA;cache.put(key, value);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：Long a = 2l;  写的是数字的 21，还是 Long 型的 2?&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）  跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2）  应用内共享常量：放置在一方库的 modules 中的 constant 目录下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;类 A 中：public static final String YES = &amp;quot;yes&amp;quot;;&#xA;类 B 中：public static final String YES = &amp;quot;y&amp;quot;;&#xA;A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致产生线上问题。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3）  子工程内部共享常量：即在当前子工程的 constant 目录下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4）  包内共享常量：即在当前包下单独的 constant 目录下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5）  类内共享常量：直接在类内部 private static final 定义。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】如果变量值仅在一个范围内变化用 Enum 类。如果还带有名称之外的延伸属性，必须使用 Enum 类，下面正例中的数字就是延伸信息，表示星期几。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public Enum  { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(三)  格式规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  左大括号前不换行。&#xA;2）  左大括号后换行。&#xA;3）  右大括号前换行。&#xA;4）  右大括号后还有 else 等代码则不换行；表示终止右大括号后必须换行。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】  左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空&#xA;格。详见第 5 条下方正例提示。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】if/for/while/switch/do 等保留字与左右括号之间都必须加空格。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】任何运算符左右必须加一个空格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：运算符包括赋值运算符=、逻辑运算符&amp;amp;&amp;amp;、加减乘除符号、三目运算符等。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】缩进采用 4 个空格，禁止使用 tab 字符。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： （涉及 1-5 点）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void main(String[]  args) { &#xA;    //  缩进 4 个空格   &#xA;    String say = &amp;quot;hello&amp;quot;; &#xA;    //  运算符的左右必须有一个空格 &#xA;    int flag = 0; &#xA;    //  关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格   &#xA;    if (flag == 0) { &#xA;        System.out.println(say); &#xA;    } &#xA;    //  左大括号前加空格且不换行；左大括号后换行 &#xA;    if (flag == 1) { &#xA;        System.out.println(&amp;quot;world&amp;quot;); &#xA;        //  右大括号前换行，右大括号后有 else，不用换行   &#xA;    } else { &#xA;        System.out.println(&amp;quot;ok&amp;quot;); &#xA;        //  在右大括号后直接结束，则必须换行   &#xA;    } &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。&#xA;2）  运算符与下文一起换行。&#xA;3）  方法调用的点符号与下文一起换行。&#xA;4）  在多个参数超长，逗号后进行换行。&#xA;5）  在括号前不要换行，见反例。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;StringBuffer sb = new StringBuffer(); &#xA;//超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 &#xA;sb.append(&amp;quot;zi&amp;quot;).append(&amp;quot;xin&amp;quot;)... &#xA;.append(&amp;quot;huang&amp;quot;)... &#xA;.append(&amp;quot;huang&amp;quot;)... &#xA;.append(&amp;quot;huang&amp;quot;); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;StringBuffer sb = new StringBuffer(); &#xA;//超过 120 个字符的情况下，不要在括号前换行 &#xA;sb.append(&amp;quot;zi&amp;quot;).append(&amp;quot;xin&amp;quot;)...append &#xA;(&amp;quot;huang&amp;quot;); &#xA;//参数很多的方法调用可能超过 120 个字符，不要在逗号前换行&#xA;method(args1, args2, args3, ... &#xA;, argsX); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：下例中实参的&amp;rdquo;a&amp;rdquo;,后边必须要有一个空格。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;method(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;int a = 3; &#xA;long b = 4L; &#xA;float c = 5F; &#xA;StringBuffer sb = new StringBuffer(); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：没有必要插入多行空格进行隔开。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(四)  OOP 规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】所有的覆写方法，必须加@Override 注解。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：public User getUsers(String type, Integer&amp;hellip; ids)&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】不能使用过时的类或方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：java.net.URLDecoder  中的方法 decode(String  encodeStr)  这个方法已经过时，应该使用双参数 decode(String  source,  String  encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： &amp;ldquo;test&amp;rdquo;.equals(object);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例： object.equals(&amp;ldquo;test&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 推荐使用 java.util.Objects#equals  （JDK7 引入的工具类）&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：对于 Integer var = ?在-128 至 127 之间的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;关于基本数据类型与包装数据类型的使用标准如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  【强制】所有的 POJO 类属性必须使用包装数据类型。&#xA;2）  【强制】RPC 方法的返回值和参数必须使用包装数据类型。&#xA;3）  【推荐】所有的局部变量使用基本数据类型。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&amp;gt;  generate  toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;String str = &amp;quot;a,b,c,,&amp;quot;; &#xA;String[] ary = str.split(&amp;quot;,&amp;quot;); &#xA;//预期大于 3，结果是 3&#xA;System.out.println(ary.length); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】  类内方法定义顺序依次是：公有方法或保护方法  &amp;gt;  私有方法  &amp;gt; getter/setter方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名  =  参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题的难度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public Integer getData()  { &#xA;    if (true)  { &#xA;        return data + 100; &#xA;    }  else  {&#xA;        return data  -  100;&#xA;    } &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;String str = &amp;quot;start&amp;quot;; &#xA;for  (int  I  =  0;  I  &amp;lt;  100; i++)  { &#xA;    str = str + &amp;quot;hello&amp;quot;; &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】下列情况，声明成 final 会更有提示性：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  不需要重新赋值的变量，包括类属性、局部变量。&#xA;2）  对象参数前加 final，表示不允许修改引用的指向。&#xA;3）  类方法确定不允许被重写。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】慎用 Object 的 clone 方法来拷贝对象。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】类成员与方法访问控制从严：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。&#xA;2）  工具类不允许有 public 或 default 构造方法。&#xA;3）  类非 static 成员变量并且与子类共享，必须是 protected。&#xA;4）  类非 static 成员变量并且仅在本类使用，必须是 private。&#xA;5）  类 static 成员变量如果仅在本类使用，必须是 private。&#xA;6）  若是 static 成员变量，必须考虑是否为 final。&#xA;7）  类成员方法只供类内部调用，必须是 private。&#xA;8）  类成员方法只对继承类公开，那么限制为 protected。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 Service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(五)  集合处理&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】关于 hashCode 和 equals 的处理，遵循如下规则：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1） 只要重写 equals，就必须重写 hashCode。&#xA;2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的&#xA;对象必须重写这两个方法。&#xA;3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】   ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException&lt;/p&gt;&#xA;&#xA;&lt;p&gt;异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：subList  返回的是  ArrayList  的内部类  SubList，并不是  ArrayList  ，而是ArrayList  的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】  在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException  异常。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】使用集合转数组的方法，必须使用集合的 toArray(T[]  array)，传入的是类型完全一样的数组，大小就是 list.size()。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 使用 toArray 带参方法，入参分配的数组空间不够大时， toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[  list.size()  ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(2); &#xA;list.add(&amp;quot;guan&amp;quot;); &#xA;list.add(&amp;quot;bao&amp;quot;); &#xA;String[] array = new String[list.size()]; &#xA;array = list.toArray(array); &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;String[] str = new String[] { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot; };&#xA;List list = Arrays.asList(str); &#xA;第一种情况：list.add(&amp;quot;c&amp;quot;);  运行时异常。&#xA;第二种情况：str[0] = &amp;quot;gujin&amp;quot;;  那么 list.get(0)也会随之修改。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】泛型通配符&amp;lt;? extends T&amp;gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&amp;lt;? super T&amp;gt;不能使用 get 方法，做为接口调用赋值时易出错。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：1）频繁往外读取内容的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; a = new ArrayList&amp;lt;String&amp;gt;(); &#xA;a.add(&amp;quot;1&amp;quot;); &#xA;a.add(&amp;quot;2&amp;quot;); &#xA;for (String temp : a) { &#xA;    if  (&amp;quot;1&amp;quot;.equals(temp))  { &#xA;        a.remove(temp); &#xA;    } &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Iterator&amp;lt;String&amp;gt; it = a.iterator(); &#xA;while  (it.hasNext())  { &#xA;    String temp =  it.next(); &#xA;    if  (删除元素的条件)  {   &#xA;        it.remove(); &#xA;    } &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】  在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  x，y 的比较结果和 y，x 的比较结果相反。&#xA;2）  x&amp;gt;y，y&amp;gt;z，则 x&amp;gt;z。&#xA;3）  x=y，则 x，z 比较结果和 y，z 比较结果相同。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;反例：下例中没有处理相等的情况，实际使用中可能会出现异常：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;new Comparator&amp;lt;Student&amp;gt;() { &#xA;    @Override &#xA;    public int compare(Student o1, Student o2) { &#xA;        return o1.getId() &amp;gt; o2.getId() ? 1 :  -1; &#xA;    } &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】集合初始化时，尽量指定集合初始值大小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：ArrayList 尽量使用 ArrayList(int initialCapacity)  初始化。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font color=&#34;#AD8022&#34; size = &#34;4px&#34;&gt;说明：&lt;/font&gt;&#xA;keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th align=&#34;center&#34;&gt;集合类&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;Key&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;Value&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;Super&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;说明&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;ConcurrentHashMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;不允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;不允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;AbstractMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;分段锁技术&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;TreeMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;不允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;AbstractMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;线程不安全&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;HashMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;允许为 null&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;AbstractMap&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;线程不安全&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;反例：  由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，注意存储null 值时会抛出 NPE 异常。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 有序性是指遍历的结果是按某种比较规则依次排列的。 稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(六)  并发处理&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：资源驱动类、工具类、单例工厂类都需要注意。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&#xA;    public class TimerTaskThread extends Thread {&#xA;        public TimerTaskThread()  {&#xA;            super.setName(&amp;ldquo;TimerTaskThread&amp;rdquo;);    &amp;hellip;&#xA;        }&#xA;    }&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：Executors 返回的线程池对象的弊端如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）FixedThreadPool 和 SingleThreadPool:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2）CachedThreadPool 和 ScheduledThreadPool:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】SimpleDateFormat  是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;正例：注意线程安全，使用 DateUtils。亦推荐如下处理：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    private static final ThreadLocal&amp;lt;DateFormat&amp;gt; df = new ThreadLocal&amp;lt;DateFormat&amp;gt;() { &#xA;        @Override &#xA;        protected DateFormat initialValue() { &#xA;            return new SimpleDateFormat(&amp;quot;yyyy-MM-dd&amp;quot;); &#xA;        } &#xA;    }; &#xA;&#xA;说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释： simple  beautiful  strong immutable thread-safe。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：线程一需要对表 A、B、 C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed  导致的性能下降。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：Random 实例包括 java.util.Random  的实例或者  Math.random()实例。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：在 JDK7 之后，可以直接使用 API  ThreadLocalRandom，在  JDK7 之前，可以做到每个线程一个实例。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】在并发场景下，通过双重检查锁（double-checked  locking）实现延迟初始化的优化问题隐患(可参考  The &amp;ldquo;Double-Checked Locking is Broken&amp;rdquo; Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为  volatile 型。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Foo { &#xA;    private Helper helper = null; &#xA;    public Helper getHelper() { &#xA;        if (helper == null)  synchronized(this) { &#xA;            if (helper == null) &#xA;                helper = new Helper(); &#xA;        } &#xA;        return helper; &#xA;    } &#xA;    // other functions and members... &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果是 count++操作，使用如下类实现：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;AtomicInteger  count  =  new  AtomicInteger();  count.addAndGet(1);  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】  HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量  ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(七)  控制语句&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】在 if/else/for/while/do 语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) tatements;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】推荐尽量少用 else，  if-else 的方式可以改写成：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if  (condition)  { &#xA;...&#xA;return obj; &#xA;} &#xA;//  接着写 else 的业务逻辑代码; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：如果非得使用 if()&amp;hellip;else if()&amp;hellip;else&amp;hellip;方式表达逻辑，【强制】请勿超过 3 层，超过请使用状态设计模式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//伪代码如下&#xA;boolean existed = (file.open(fileName, &amp;quot;w&amp;quot;) != null)  &amp;amp;&amp;amp;  (...) || (...);&#xA;if (existed) {&#xA;...&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;反例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if ((file.open(fileName, &amp;quot;w&amp;quot;) != null)  &amp;amp;&amp;amp;  (...) || (...)) {&#xA;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作 （这个 try-catch 是否可以移至循环体外） 。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】方法中需要进行参数校验的场景：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  调用频次低的方法。&#xA;2）  执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致&#xA;中间执行回退，或者错误，那得不偿失。 &#xA;3）  需要极高稳定性和可用性的方法。&#xA;4）  对外提供的开放接口，不管是 RPC/API/HTTP 接口。&#xA;5）  敏感权限入口。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】方法中不需要参数校验的场景：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）  极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查要求。&#xA;2）  底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。&#xA;3）  被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(八)  注释规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*&lt;em&gt;内容&lt;/em&gt;/格式，不得使用//xxx 方式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：对子类的实现要求，或者调用注意事项，请一并说明。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】所有的类都必须添加创建者信息。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：&#xA;    // put elephant into fridge&#xA;    put(elephant, fridge);&#xA;    方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）  待办事宜（TODO）:（  标记人，标记时间，[预计处理时间]）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法 （因为它是一个 Javadoc 标签） 。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2）  错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;(九)  其它&lt;/h3&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】 velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果 var=null 或者不存在，那么${var}会直接显示在页面上。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】注意  Math.random()  这个方法返回是 double 类型，注意取值的范围  0≤x&amp;lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】获取当前毫秒数 System.currentTimeMillis();  而不是 new Date().getTime();&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime()。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】尽量不要在 velocity 模板中加入变量声明、逻辑运算符，更不要在模板中加入任何复杂的逻辑。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;二、异常日志&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;(一)  异常处理&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】Java  类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch  来处理，比如：IndexOutOfBoundsException，NullPointerException 等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch NumberFormatException 来实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：if (obj != null) {&amp;hellip;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：try { obj.method() } catch (NullPointerException e) {&amp;hellip;}&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。说明：如果 JDK7 及以上，可以使用 try-with-resources 方式。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】不能在 finally 块中使用 return， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) 返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;反例：public int f() { return Integer 对象};  &#xA;     如果为 null，自动解箱抛 NPE。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2) 数据库的查询结果可能为 null。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3) 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4）  远程调用返回对象，一律要求进行 NPE 判断。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5）  对于 Session 中获取的数据，建议 NPE 检查，避免空指针。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;6）  级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;正例：可以使用 JDK8 的 Optional 类来防止 NPE 问题。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess、“错误码”、“错误简短信息”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：关于 RPC 方法返回方式使用 Result 方式的理由：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】定义时区分 unchecked  /  checked  异常，避免直接使用 RuntimeException 抛出，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：&#xA;    private boolean checkParam(DTO dto)  {&amp;hellip;}&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;(二)  日志规约&lt;/h3&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import org.slf4j.Logger; &#xA;import org.slf4j.LoggerFactory;&#xA;private static final Logger logger = LoggerFactory.getLogger(Abc.class); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;appName_logType_logName.log。&#xA;logType:日志类型，推荐分类有stats/desc/monitor/visit 等；&#xA;logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：mppserver 应用中单独监控时区转换异常，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mppserver_monitor_timeZoneConvert.log&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：logger.debug(&amp;ldquo;Processing  trade  with  id: &amp;ldquo; +  id  + &amp;rdquo;  symbol: &amp;ldquo; +  symbol);&#xA;如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：（条件）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (logger.isDebugEnabled()) { &#xA;    logger.debug(&amp;quot;Processing trade with id: &amp;quot; + id + &amp;quot; symbol: &amp;quot; + symbol); &#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;正例：（占位符）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;logger.debug(&amp;quot;Processing trade with id: {} symbol : {} &amp;quot;, id, symbol); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：&lt;logger name=&#34;com.taobao.dubbo.config&#34; additivity=&#34;false&#34;&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：logger.error(各类参数或者对象 toString + &amp;ldquo;_&amp;rdquo; + e.getMessage(), e);&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;三、MySQL 规约&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;(一)  建表规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned  tinyint（  1 表示是，0 表示否）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：任何字段如果为非负数，必须是 unsigned。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：getter_admin，task_config，level3_name&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：GetterAdmin，taskConfig，level_3_name&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】表名不使用复数名词。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：pk_  即 primary key；uk_  即  unique key；idx_  即 index 的简称。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】小数类型为 decimal，禁止使用 float 和 double。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】表必备三字段：id, gmt_create, gmt_modified。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create,gmt_modified 的类型均为 date_time 类型。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】表的命名最好是加上“业务名称_表的作用”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：tiger_task / tiger_reader / mpp_config&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】库名与应用名称尽量一致。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1）不是频繁修改的字段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2）不是 varchar 超长字段，更不能是 text 字段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：无符号值可以避免误存负数，且扩大了表示范围。&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th align=&#34;center&#34;&gt;对象&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;年龄区间&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;类型&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;表示范围&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;人&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;150 岁之内&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;unsigned tinyint&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;无符号值：0 到 255&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;龟&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;数百岁&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;unsigned smallint&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;无符号值：0 到 65535&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;恐龙化石&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;数千万年&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;unsigned int&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;无符号值：0 到约 42.9 亿&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;太阳&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;约 50 亿年&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;unsigned bigint&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;无符号值：0 到约 10 的 19 次方&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(二)  索引规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】  超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：即使双表 join 也要注意表索引、SQL 性能。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct  left(列名,  索引长度))/count(*)的区分度来确定。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by  最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：where a=? and b=? order by c;  索引：a_b_c&lt;/p&gt;&#xA;&#xA;&lt;p&gt;反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&amp;gt;10 ORDER BY b;  索引a_b 无法排序。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】利用覆盖索引来进行查询操作，避免回表。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】利用延迟关联或者子查询优化超多分页场景。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：先快速定位需要获取的 id 段，然后再关联：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SELECT a.* FROM  表 1 a, (select id from  表 1 where  条件  LIMIT 100000,20 )  b where a.id=b.id &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】   SQL 性能优化的目标：至少要达到  range  级别， 要求是 ref 级别， 如果可以是 consts最好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1） consts  单表中最多只有一个匹配行 （主键或者唯一索引） ，在优化阶段即可读取到数据。&#xA;2）ref  指的是使用普通的索引（normal index）。&#xA;3）range  对索引进行范围检索。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】建组合索引的时候，区分度最高的在最左边。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：如果 where  a=?  and  b=?  ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如： where  a&amp;gt;? and b=?  那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】创建索引时避免有如下极端误解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1）误认为一个查询就需要建一个索引。&#xA;2）误认为索引会消耗空间、严重拖慢更新和新增速度。&#xA;3）误认为唯一索引一律需要在应用层通过“先查后插”方式解决。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(三)  SQL 规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】不要使用 count(列名)或 count(常量)来替代 count(&lt;em&gt;)， count(&lt;/em&gt;)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】count(distinct  col)  计算该列除 NULL 之外的不重复行数，注意  count(distinctcol1, col2)  如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】 当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1） NULL&amp;lt;&amp;gt;NULL 的返回结果是 NULL，而不是 false。&#xA;2） NULL=NULL 的返回结果是 NULL，而不是 true。&#xA;3） NULL&amp;lt;&amp;gt;1 的返回结果是 NULL，而不是 true。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】   在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】不得使用外键与级联，一切外键概念必须在应用层解决。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： （概念解释） 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，那么字符计数方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;SELECT LENGTH(&amp;quot;轻松工作&amp;quot;)；  返回为 12&#xA;SELECT CHARACTER_LENGTH(&amp;quot;轻松工作&amp;quot;)；  返回为 4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】   TRUNCATE  TABLE  比  DELETE  速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：TRUNCATE TABLE  在功能上与不带  WHERE  子句的  DELETE  语句相同。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(四)  ORM 规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】在表查询中，一律不要使用  *  作为查询的字段列表，需要哪些字段必须明确写明。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】POJO 类的 Boolean 属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;说明：参见定义 POJO 类以及数据库字段定义规定，在&lt;resultMap&gt;中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行适当的修改。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;说明：配置映射关系，使字段与 DO 类解耦，方便维护。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】xml 配置中参数注意：#{}，#param#  不要使用${}  此种方式容易出现 SQL 注入。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】iBATIS 自带的 queryForList(String statementName,int start,int  size)不推荐使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明： 其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList取 start,size 的子集合，线上因为这个原因曾经出现    过 OOM。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;正例：在 sqlmap.xml 中引入  #start#, #size#&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;(); &#xA;map.put(&amp;quot;start&amp;quot;, start); &#xA;map.put(&amp;quot;size&amp;quot;, size); &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3;  这是不对的。执行 SQL时，尽量不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】 &lt;isEqual&gt;中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；&lt;isNotEmpty&gt;表示不为空且不为 null 时执行；&lt;isNotNull&gt;表示不为 null 值时执行。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;四、工程规约&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;(一)  应用分层&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推：&#xA;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/ali.png&#34; alt=&#34;ali&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。&lt;/li&gt;&#xA;&lt;li&gt;终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP渲染，移动端展示等。&lt;/li&gt;&#xA;&lt;li&gt;Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。&lt;/li&gt;&#xA;&lt;li&gt;Service 层：相对具体的业务逻辑服务层。&lt;/li&gt;&#xA;&lt;li&gt;Manager 层：通用业务处理层，它有如下特征：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对第三方平台封装的层，预处理返回结果及转化异常信息；&lt;/li&gt;&#xA;&lt;li&gt;对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；&lt;/li&gt;&#xA;&lt;li&gt;与 DAO 层交互，对多个 DAO 的组合复用。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;li&gt;DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。&lt;/li&gt;&#xA;&lt;li&gt;外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】  （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO&#xA;层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。 Web 层绝不应该继续往上抛异常,因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】分层领域模型规约：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。&lt;/li&gt;&#xA;&lt;li&gt;DTO（Data Transfer Object）：数据传输对象，Service 和 Manager 向外传输的对象。&lt;/li&gt;&#xA;&lt;li&gt;BO（Business Object）：业务对象。可以由 Service 层输出的封装业务逻辑的对象。&lt;/li&gt;&#xA;&lt;li&gt;QUERY：数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。&lt;/li&gt;&#xA;&lt;li&gt;VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(二)  二方库规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】定义 GAV 遵从以下规则：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;说明： {公司/BU}  例如： alibaba/taobao/tmall/aliexpress 等 BU 一级； 子业务线可选。&#xA;正例：com.taobao.jstorm  或 com.alibaba.dubbo.register&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;正例：dubbo-client / fastjson-api / jstorm-tool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3） Version：详细规定参考下方。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】二方库版本号命名方式：主版本号.次版本号.修订号&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主版本号：当做了不兼容的 API  修改，或者增加了能改变产品方向的新功能。&lt;/li&gt;&#xA;&lt;li&gt;次版本号：当做了向下兼容的功能性新增（新增类、接口等）。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;修订号：修复 bug，没有修改方法签名的功能加强，保持  API  兼容性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说明：起始版本号必须为：1.0.0，而不是 0.0.1&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使 RELEASE 版本号有延续性，版本号不允许覆盖升级。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。&#xA;当前版本：1.3.3，那么下一个合理的版本号：1.3.4  或  1.4.0  或  2.0.0&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证， 建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行&lt;excludes&gt;排除 jar 包。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】所有 pom 文件中的依赖声明放在&lt;dependencies&gt;语句块中，所有版本仲裁放在&lt;dependencyManagement&gt;语句块中。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：&lt;dependencyManagement&gt;里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而&lt;dependencies&gt;所有声明在主 pom 的&lt;dependencies&gt;里的依赖都会自动引入，并默认被所有的子项目继承。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】二方库尽量不要有配置项，最低限度不要再增加配置项。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;精简可控原则。移除一切不必要的 API 和依赖，只包含  Service  API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。&lt;/li&gt;&#xA;&lt;li&gt;稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;(三)  服务器规约&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout = 30&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open  too  many  files”错误，导致新的连接无法建立。   建议将 linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;五、安全规约&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】用户敏感数据禁止直接展示，必须对展示数据脱敏。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】用户请求传入的任何参数必须做有效性验证。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：忽略参数校验可能导致：&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;page size 过大导致内存溢出&lt;/li&gt;&#xA;&lt;li&gt;恶意 order by 导致数据库慢查询&lt;/li&gt;&#xA;&lt;li&gt;任意重定向&lt;/li&gt;&#xA;&lt;li&gt;SQL 注入&lt;/li&gt;&#xA;&lt;li&gt;反序列化注入&lt;/li&gt;&#xA;&lt;li&gt;正则输入源串拒绝服务 ReDoS&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说明： 如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;附 1：版本历史&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th align=&#34;center&#34;&gt;版本号&lt;/th&gt;&#xA;&lt;th align=&#34;center&#34;&gt;更新日期&lt;/th&gt;&#xA;&lt;th align=&#34;left&#34;&gt;备注&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;1.0.0&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;2017.2.9&lt;/td&gt;&#xA;&lt;td align=&#34;left&#34;&gt;阿里巴巴正式对外发布&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;1.0.1&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;2017.2.13&lt;/td&gt;&#xA;&lt;td align=&#34;left&#34;&gt;1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;1.0.2&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;2017.2.20&lt;/td&gt;&#xA;&lt;td align=&#34;left&#34;&gt;1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final 描述。5）去除 Comparator 部分描述。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td align=&#34;center&#34;&gt;1.1.0&lt;/td&gt;&#xA;&lt;td align=&#34;center&#34;&gt;2017.2.27&lt;/td&gt;&#xA;&lt;td align=&#34;left&#34;&gt;1）增加前言。2）增加&amp;lt;? extends T&amp;gt;描述和说明。3）增加版本历史。4）增加专有名词解释。&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;附 2：本规约专有名词&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;POJO&lt;/strong&gt;（Plain Ordinary Java Object）：在本规约中，POJO 专指只有setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DO&lt;/strong&gt;（Data Object）：本手册指数据库表一一对应的 POJO 类。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;GAV&lt;/strong&gt;（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;OOP&lt;/strong&gt;（Object Oriented Programming）:  本手册泛指类、对象的编程处理方式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ORM&lt;/strong&gt;（Object Relation Mapping）:  对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS, mybatis 等框架。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;NPE&lt;/strong&gt;（java.lang.NullPointerException）:  空指针异常。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一方库&lt;/strong&gt;：本工程内部子项目模块依赖的库（jar 包）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;二方库&lt;/strong&gt;：公司内部发布到中央仓库，可供公司内部依赖的库（jar 包）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;三方库&lt;/strong&gt;：公司之外的开源的依赖库（jar 包）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;附 3：法律声明&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本手册为阿里巴巴集团技术部的技术分享，版权归阿里巴巴集团所有，仅供大家交流、学习及研究使用，禁止用于商业用途，违者必究&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>java代理</title>
      <link>http://sakyawang.github.io/default/java%E4%BB%A3%E7%90%86/</link>
      <pubDate>2015-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;（1）Proxy 毕竟是通过反射实现的，必须在效率上付出代价：有实验数据表明，调用反射比一般的函数开销至少要大 10 倍。而且，从程序实现上可以看出，对 proxy class 的所有方法调用都要通过使用反射的 invoke 方法。因此，对于性能关键的应用，使用 proxy class 是需要精心考虑的，以避免反射成为整个应用的瓶颈。（2）CGLib封装了asm，可以再运行期动态生成新的class。ASM 能够通过改造既有类，直接生成需要的代码。增强的代码是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。同时，ASM 与 Proxy 编程不同，不需要为增强代码而新定义一个接口，生成的代码可以覆盖原来的类，或者是原始类的子类。（3）CGLib在不同频次的调用性能会发生变化，体现为调用频次越高、性能越好。（4）不同版本的JDK中JDK Proxy的性能也不尽相同，越高版本的JDK（JDK7及以上），性能提升越明显。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>设计模式解读之一： 策略模式</title>
      <link>http://sakyawang.github.io/设计模式/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%E4%B9%8B%E4%B8%80%EF%BC%9A-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2015-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;转自：&lt;a href=&#34;http://www.javaeye.com/topic/328262&#34;&gt;http://www.javaeye.com/topic/328262&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当我们掌握了Java的语法，当我们了解了面向对象的封装、继承、多态等特性，当我们可以用Swing、Servlet、JSP技术构建桌面以及Web应用，不意味着我们可以写出面向对象的程序，不意味着我们可以很好的实现代码复用，弹性维护，不意味着我们可以实现在维护、扩展基础上的代码复用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一把刀，可以使你制敌于无形而于江湖扬名，也可以只是一把利刃而使你切菜平静。Java，就是这把刀，它的威力取决于你使用的方式。当我们陷入无尽无止重复代码的泥沼，当我们面临牵一发而动全身的维护恶梦, 你应该想起“设计模式”这个行动秘笈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;面向对象的精义，看似平淡，其实要经过艰苦实践才能成功。而构造OO系统的隐含经验于是被前人搜集而成并冠以“设计模式”之名。我们应该在编码行动初始就携带以它。接下来，让我们步“四人组”先行者之后，用中国文字、用实际案例领略模式于我们代码焕然一新的改变。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;设计模式解读之一： 策略模式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. 模式定义&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把会变化的内容取出并封装起来，以便以后可以轻易地改动或扩充部分，而不影响不需要变化的其他部分；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. 问题缘起&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当涉及至代码维护时，为了复用目的而使用继承，结局并不完美。对父类的修改，会影响到子类型。在超类中增加的方法，会导致子类型有该方法，甚至连那些不该具备该方法的子类型也无法免除。示例，一个鸭子类型：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class Duck {&#xA;    //所有的鸭子均会叫以及游泳，所以父类中处理这部分代码&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack&amp;quot;);&#xA;    }&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    //因为每种鸭子的外观是不同的，所以父类中该方法是抽象的，由子类型自己完成。&#xA;    public abstract void display();&#xA;}&#xA;&#xA;public class MallardDuck extends Duck {&#xA;    //野鸭外观显示为绿头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;public class RedHeadDuck extends Duck {&#xA;    //红头鸭显示为红头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Red head.&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;public class RubberDuck extends Duck {&#xA;    //橡皮鸭叫声为吱吱叫，所以重写父类以改写行为&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak&amp;quot;);&#xA;    }&#xA;&#xA;    //橡皮鸭显示为黄头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Yellow head.&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述代码，初始实现得非常好。现在我们如果给Duck.java中加入fly()方法的话，那么在子类型中均有了该方法，于是我们看到了 会飞的橡皮鸭子，你看过吗？当然，我们可以在子类中通过空实现重写该方法以解决该方法对于子类型的影响。但是父类中再增加其它的方法呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过继承在父类中提供行为，会导致以下缺点：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码在多个子类中重复;&lt;/li&gt;&#xA;&lt;li&gt;运行时的行为不容易改变；&lt;/li&gt;&#xA;&lt;li&gt;改变会牵一发动全身，造成部分子类型不想要的改变；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;好啦，还是刚才鸭子的例子，你也许想到使用接口，将飞的行为、叫的行为定义为接口，然后让Duck的各种子类型实现这些接口。这时侯代码类似于：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class Duck {&#xA;    //将变化的行为 fly() 以及quake()从Duck类中分离出去定义形成接口，有需求的子类中自行去实现&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    public abstract void display();&#xA;}&#xA;&#xA;//变化的 fly() 行为定义形成的接口&#xA;public interface FlyBehavior {&#xA;    void fly();&#xA;}&#xA;&#xA;//变化的 quack() 行为定义形成的接口&#xA;public interface QuackBehavior {&#xA;    void quack();&#xA;}&#xA;&#xA;//野鸭子会飞以及叫，所以实现接口  FlyBehavior, QuackBehavior&#xA;public class MallardDuck extends Duck implements FlyBehavior, QuackBehavior{&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;Fly.&amp;quot;);                &#xA;    }&#xA;&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack.&amp;quot;);                &#xA;    }&#xA;}&#xA;&#xA;//红头鸭子会飞以及叫，所以也实现接口  FlyBehavior, QuackBehavior&#xA;public class RedHeadDuck extends Duck implements FlyBehavior, QuackBehavior{&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Red head.&amp;quot;);&#xA;    }    &#xA;&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;Fly.&amp;quot;);                &#xA;    }&#xA;&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack.&amp;quot;);                &#xA;    }    &#xA;}&#xA;&#xA;//橡皮鸭不会飞，但会吱吱叫，所以只实现接口QuackBehavior&#xA;public class RubberDuck extends Duck implements QuackBehavior{&#xA;    //橡皮鸭叫声为吱吱叫&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak&amp;quot;);&#xA;    }&#xA;&#xA;    //橡皮鸭显示为黄头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Yellow head.&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述代码虽然解决了一部分问题，让子类型可以有选择地提供一些行为(例如 fly() 方法将不会出现在橡皮鸭中).但我们也看到，野鸭子MallardDuck.java和红头鸭子RedHeadDuck.java的一些相同行为代码不能得到重复使用。很大程度上这是从一个火坑跳到另一个火坑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在一段程序之后，让我们从细节中跳出来，关注一些共性问题。不管使用什么语言，构建什么应用，在软件开发上，一直伴随着的不变的真理是：需要一直在变化。不管当初软件设计得多好，一段时间之后，总是需要成长与改变，否则软件就会死亡。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们知道，继承在某种程度上可以实现代码重用，但是父类(例如鸭子类Duck)的行为在子类型中是不断变化的，让所有子类型都有这些行为是不恰当的。我们可以将这些行为定义为接口，让Duck的各种子类型去实现，但接口不具有实现代码，所以实现接口无法达到代码复用。这意味着，当我们需要修改某个行为，必须往下追踪并在每一个定义此行为的类中修改它，一不小心，会造成新的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设计原则：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;把应用中变化的地方独立出来，不要和那些不需要变化的代码混在一起。&#xA;这样代码变化引起的不经意后果变少，系统变得更有弹性。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;按照上述设计原则，我们重新审视之前的Duck代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1) 分开变化的内容和不变的内容&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck类中的行为 fly(), quack(), 每个子类型可能有自己特有的表现，这就是所谓的变化的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck类中的行为 swim() 每个子类型的表现均相同，这就是所谓不变的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们将变化的内容从Duck()类中剥离出来单独定义形成接口以及一系列的实现类型。将变化的内容定义形成接口可实现变化内容和不变内容的剥离。其实现类型可实现变化内容的重用。这些实现类并非Duck.java的子类型，而是专门的一组实现类，称之为&amp;rdquo;行为类&amp;rdquo;。由行为类而不是Duck.java的子类型来实现接口。这样，才能保证变化的行为独立于不变的内容。于是我们有：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;变化的内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   //变化的 fly() 行为定义形成的接口&#xA;   public interface FlyBehavior {&#xA;    void fly();&#xA;   }&#xA;&#xA;   //变化的 fly() 行为的实现类之一&#xA;   public class FlyWithWings implements FlyBehavior {&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;I&#39;m flying.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 fly() 行为的实现类之二&#xA;   public class FlyNoWay implements FlyBehavior {&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;I can&#39;t fly.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;       -----------------------------------------------------------------&#xA;&#xA;   //变化的 quack() 行为定义形成的接口&#xA;   public interface QuackBehavior {&#xA;    void quack();&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之一&#xA;   public class Quack implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之二&#xA;   public class Squeak implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之三&#xA;   public class MuteQuack implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;&amp;lt;&amp;lt; Slience &amp;gt;&amp;gt;&amp;quot;);&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过以上设计，fly()行为以及quack()行为已经和Duck.java没有什么关系，可以充分得到复用。而且我们很容易增加新的行为, 既不影响现有的行为，也不影响Duck.java。但是，大家可能有个疑问，就是在面向对象中行为不是体现为方法吗？为什么现在被定义形成类(例如Squeak.java)？在OO中，类代表的&amp;rdquo;东西&amp;rdquo;一般是既有状态(实例变量）又有方法。只是在本例中碰巧&amp;rdquo;东西&amp;rdquo;是个行为。既使是行为，也有属性及方法，例如飞行行为，也需要一些属性记录飞行的状态，如飞行高度、速度等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2) 整合变化的内容和不变的内容&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck.java将 fly()以及quack()的行为委拖给行为类处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不变的内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public abstract class Duck {&#xA;        //将行为类声明为接口类型，降低对行为实现类型的依赖&#xA;    FlyBehavior flyBehavior;&#xA;    QuackBehavior quackBehavior;&#xA;&#xA;    public void performFly() {&#xA;        //不自行处理fly()行为，而是委拖给引用flyBehavior所指向的行为对象&#xA;        flyBehavior.fly();&#xA;    }&#xA;&#xA;    public void performQuack() {&#xA;        quackBehavior.quack();&#xA;    }&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    public abstract void display();&#xA;   }&#xA;&#xA;   Duck.java不关心如何进行 fly()以及quack(), 这些细节交由具体的行为类完成。&#xA;&#xA;   public class MallardDuck extends Duck{&#xA;    public MallardDuck() {&#xA;        flyBehavior=new FlyWithWings();&#xA;        quackBehavior=new Quack();        &#xA;    }&#xA;&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试类：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public class DuckTest {&#xA;    public static void main(String[] args) {&#xA;        Duck duck=new MallardDuck();&#xA;        duck.performFly();&#xA;        duck.performQuack();        &#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Duck.java子类型MallardDuck.java的构造方法中，直接实例化行为类型，在编译的时侯便指定具体行为类型。当然，我们可以：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;我们可以通过工厂模式或其它模式进一步解藕(可参考后续模式讲解);&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;或做到在运行时动态地改变行为。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3) 动态设定行为&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在父类Duck.java中增加设定行为类型的setter方法，接受行为类型对象的参数传入。为了降藕，行为参数被声明为接口类型。这样，既便在运行时，也可以通过调用这二个方法以改变行为。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public abstract class Duck {&#xA;    //在刚才Duck.java中加入以下二个方法。&#xA;    public void setFlyBehavior(FlyBehavior flyBehavior) {&#xA;        this.flyBehavior=flyBehavior;&#xA;    }&#xA;&#xA;    public void setQuackBehavior(QuackBehavior quackBehavior) {&#xA;        this.quackBehavior=quackBehavior;&#xA;    }&#xA;&#xA;    //其它方法同，省略...&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试类：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public class DuckTest {&#xA;    public static void main(String[] args) {&#xA;        Duck duck=new MallardDuck();&#xA;        duck.performFly();&#xA;        duck.performQuack();&#xA;        duck.setFlyBehavior(new FlyNoWay());&#xA;        duck.performFly();&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果，我们要加上火箭助力的飞行行为，只需再新建FlyBehavior.java接口的实现类型。而子类型可通过调用setQuackBehavior(&amp;hellip;)方法动态改变。至此，在Duck.java增加新的行为给我们代码所带来的困绕已不复存在。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该是总结的时侯了，让我们从代码的水中浮出来，做一只在水面上自由游动的鸭子吧:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;3.  解决方案&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MallardDuck 继承  Duck抽象类；          -&amp;gt; 不变的内容&lt;/li&gt;&#xA;&lt;li&gt;FlyWithWings 实现 FlyBehavior接口；     -&amp;gt; 变化的内容,行为或算法&lt;/li&gt;&#xA;&lt;li&gt;在Duck.java提供setter方法以装配关系；    -&amp;gt; 动态设定行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;以上就是策略模式的实现三步曲。接下来，让我们透过步骤看本质:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始，我们通过继承实现行为的重用，导致了代码的维护问题。          -&amp;gt; 继承, is a&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;接着，我们将行为剥离成单独的类型并声明为不变内容的实例变量并通过  -&amp;gt; 组合, has a&#xA;setter方法以装配关系；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;继承，可以实现静态代码的复用；&#xA;组合，可以实现代码的弹性维护；&#xA;使用组合代替继承，可以使代码更好地适应软件开发完后的需求变化。&#xA;策略模式的本质：少用继承，多用组合&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>stack的三种含义</title>
      <link>http://sakyawang.github.io/转载/stack%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%AB%E4%B9%89/</link>
      <pubDate>2015-07-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文来自：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/11/stack.html&#34;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如有引用请注明，谢谢！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;#stack的三种含义&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习编程的时候，经常会看到stack这个词，它的中文名字叫做&amp;rdquo;栈&amp;rdquo;。&#xA;理解这个概念，对于理解程序的运行至关重要。容易混淆的是，这个词其实有三种含义，适用于不同的场合，必须加以区分。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;含义一：数据结构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第一种含义是一组数据的&lt;a href=&#34;http://en.wikipedia.org/wiki/Stack_(abstract_data_type)&#34;&gt;存放方式&lt;/a&gt;，特点为LIFO，即后进先出（Last in, first out）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112901.png&#34; alt=&#34;stack&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这种数据结构中，数据像积木那样一层层堆起来，后面加入的数据就放在最上层。使用的时候，最上层的数据第一个被用掉，这就叫做&amp;rdquo;后进先出&amp;rdquo;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与这种结构配套的，是一些特定的方法，主要为下面这些。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;push：在最顶层加入数据。&#xA;pop：返回并移除最顶层的数据。&#xA;top：返回最顶层数据的值，但不移除它。&#xA;isempty：返回一个布尔值，表示当前stack是否为空栈。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;含义二：代码运行方式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第二种含义是&lt;a href=&#34;http://en.wikipedia.org/wiki/Call_stack&#34;&gt;&amp;ldquo;调用栈&amp;rdquo;&lt;/a&gt;（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。&#xA;下面以一段Java代码为例（&lt;a href=&#34;http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/&#34;&gt;来源&lt;/a&gt;）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Student{&#xA;    int age;              &#xA;    String name;      &#xA;&#xA;    public Student(int Age, String Name)&#xA;    {&#xA;        this.age = Age;&#xA;        setName(Name);&#xA;    }&#xA;    public void setName(String Name)&#xA;    {&#xA;        this.name = Name;&#xA;    }&#xA;}&#xA;&#xA;public class Main{&#xA;    public static void main(String[] args) {&#xA;            Student s;           &#xA;            s = new Student(23,&amp;quot;Jonh&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段代码运行的时候，首先调用main方法，里面需要生成一个Student的实例，于是又调用Student构造函数。在构造函数中，又调用到setName方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112902.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这三次调用像积木一样堆起来，就叫做&amp;rdquo;调用栈&amp;rdquo;。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;含义三：内存区域&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第三种含义是&lt;a href=&#34;http://en.wikipedia.org/wiki/Stack-based_memory_allocation&#34;&gt;存放数据的一种内存区域&lt;/a&gt;。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做stack（栈），另一种叫做heap（堆）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112903.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它们的主要区别是：stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112904.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他的区别还有，一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据上面这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面。请看下面这段代码（&lt;a href=&#34;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types&#34;&gt;来源&lt;/a&gt;）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void Method1()&#xA;{&#xA;    int i=4;&#xA;&#xA;    int y=2;&#xA;&#xA;    class1 cls1 = new class1();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面代码的Method1方法，共包含了三个变量：i, y 和 cls1。其中，i和y的值是整数，内存占用空间是确定的，而且是局部变量，只用在Method1区块之内，不会用于区块之外。cls1也是局部变量，但是类型为指针变量，指向一个对象的实例。指针变量占用的大小是确定的，但是对象实例以目前的信息无法确知所占用的内存空间大小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这三个变量和一个对象实例在内存中的存放方式如下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112905.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从上图可以看到，i、y和cls1都存放在stack，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是，cls1指向的对象实例存放在heap，因为它的大小不确定。作为一条规则可以记住，所有的对象都存放在heap。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来的问题是，当Method1方法运行结束，会发生什么事？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;回答是整个stack被清空，i、y和cls1这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而heap之中的那个对象实例继续存在，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，一般来说，内存泄漏都发生在heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用sublime text2 编辑markdown文件并导出带目录的html</title>
      <link>http://sakyawang.github.io/markdown/%E4%BD%BF%E7%94%A8sublime-text2-%E7%BC%96%E8%BE%91markdown%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84html/</link>
      <pubDate>2015-07-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;前一篇文章介绍了使用markdown pad2来生成带目录的html文件。但是有很多程序员喜欢使用sublime来进行markdown的编写。这里介绍一下sublime下如何把markdown文件生成带目录的html。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、 sublime text2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置过程&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;sublime text 安装 markdown preview插件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;sublime text 安装插件基本配置请参看之前的一篇文章：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://sakyawang.github.io/sublime/sublime-text2-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/&#34;&gt;sublime text2 安装插件&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ctrl+shift+P 调出窗口，输入 install package --&amp;gt; 输入 markdown preview 选中安装插件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;配置markdown高亮显示&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Preferences -&amp;gt;Package Settings-&amp;gt;Markdown Preview-&amp;gt;Setting Default中找到&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;quot;enable_mathjax&amp;quot;: true,&#xA;&#xA;/*&#xA;    Enable uml support scripts: flowchart.js and sequence-diagram.js.&#xA;*/&#xA;&amp;quot;enable_uml&amp;quot;: false,&#xA;&#xA;/*&#xA;    Enable highlighting. This enables codehilite extension if not already enabled.&#xA;*/&#xA;&amp;quot;enable_highlight&amp;quot;: true,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;enable_mathjax 和 enable_highlight设置为true。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;编写markdown输出带目录的html&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;新建test.md文件，输入测试内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[TOC]&#xA;# 标题 #&#xA;## 标题1 ##&#xA;&#xA;标题1内容&#xA;&#xA;### 标题11 ###&#xA;&#xA;标题11内容&#xA;&#xA;### 标题12 ###&#xA;&#xA;标题12内容&#xA;&#xA;## 标题2 ##&#xA;&#xA;标题2内容&#xA;&#xA;### 标题21 ###&#xA;&#xA;标题21内容&#xA;&#xA;### 标题22 ###&#xA;&#xA;标题22内容&#xA;&#xA;## 标题3 ##&#xA;&#xA;标题3内容&#xA;&#xA;### 标题31 ###&#xA;&#xA;标题31内容&#xA;&#xA;### 标题32 ###&#xA;&#xA;标题32内容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置markdown preview编译生成html文件，如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/sublimeconfig.png&#34; alt=&#34;配置markdown编译&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行ctrl + B编译markdown为html&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/buildmarkdown.png&#34; alt=&#34;编译markdown&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开test.html查看效果&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/testhtml.jpg&#34; alt=&#34;效果&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关键点是在要生成目录的位置添加[TOC]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>markdown pad 生成带目录的html</title>
      <link>http://sakyawang.github.io/markdown/markdown-pad-%E7%94%9F%E6%88%90%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84html/</link>
      <pubDate>2015-07-16 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、markdown pad 2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;目的&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用markdown pad 2编辑生成wiki风格的接口文档&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用markdown pad 2的导出功能和高级设置的Html head 编辑器功能。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;工具--&amp;gt;选项--&amp;gt;高级--&amp;gt;Html head 编辑器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/markdownpadconfig.png&#34; alt=&#34;html head 编辑器&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;打开编辑器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;&#xA;    document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() {&#xA;        // 生成目录列表&#xA;        var outline = document.createElement(&amp;quot;ul&amp;quot;);&#xA;        outline.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;outline-list&amp;quot;);&#xA;        outline.style.cssText = &amp;quot;border: 1px solid #ccc;&amp;quot;;&#xA;        document.body.insertBefore(outline, document.body.childNodes[0]);&#xA;        // 获取所有标题&#xA;        var headers = document.querySelectorAll(&#39;h1,h2,h3,h4,h5,h6&#39;);&#xA;        for (var i = 0; i &amp;lt; headers.length; i++) {&#xA;            var header = headers[i];&#xA;            var hash = _hashCode(header.textContent);&#xA;            // MarkdownPad2无法为中文header正确生成id，这里生成一个&#xA;            header.setAttribute(&amp;quot;id&amp;quot;, header.tagName + hash);&#xA;            // 找出它是H几，为后面前置空格准备&#xA;            var prefix = parseInt(header.tagName.replace(&#39;H&#39;, &#39;&#39;), 10);&#xA;            outline.appendChild(document.createElement(&amp;quot;li&amp;quot;));&#xA;            var a = document.createElement(&amp;quot;a&amp;quot;);&#xA;            // 为目录项设置链接&#xA;            a.setAttribute(&amp;quot;href&amp;quot;, &amp;quot;#&amp;quot; + header.tagName + hash)&#xA;            // 目录项文本前面放置对应的空格&#xA;            a.innerHTML = new Array(prefix * 4).join(&#39;&amp;amp;nbsp;&#39;) + header.textContent;&#xA;            outline.lastChild.appendChild(a);&#xA;        }&#xA;&#xA;    });&#xA;&#xA;    // 类似Java的hash生成方式，为一段文字生成一段基本不会重复的数字&#xA;    function _hashCode(txt) {&#xA;         var hash = 0;&#xA;         if (txt.length == 0) return hash;&#xA;         for (i = 0; i &amp;lt; txt.length; i++) {&#xA;              char = txt.charCodeAt(i);&#xA;              hash = ((hash&amp;lt;&amp;lt;5)-hash)+char;&#xA;              hash = hash &amp;amp; hash; // Convert to 32bit integer&#xA;         }&#xA;         return hash;&#xA;    }&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;保存&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;测试效果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;新建test.md编辑：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;## 标题1&#xA;标题1内容&#xA;### 标题11&#xA;标题11内容&#xA;### 标题12&#xA;标题12内容&#xA;## 标题2&#xA;标题2内容&#xA;### 标题21&#xA;标题21内容&#xA;### 标题22&#xA;标题22内容&#xA;## 标题3&#xA;标题3内容&#xA;### 标题31&#xA;标题31内容&#xA;### 标题32&#xA;标题32内容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;导出html文件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/export.png&#34; alt=&#34;导出html文件&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看html文件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/html.png&#34; alt=&#34;查看html&#34; /&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>记一次处理http请求返回json数据中文乱码问题</title>
      <link>http://sakyawang.github.io/java/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>2015-07-10 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;项目中rest接口返回中文错误提示信息显示乱码。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;apache httpClient&lt;/p&gt;&#xA;&#xA;&lt;p&gt;spring mvc&lt;/p&gt;&#xA;&#xA;&lt;p&gt;tomcat&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理过程&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;分析理清问题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;接口部署在本地tomcat上时，使用Apache httpClient客户端访问无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接口部署到服务器上的tomcat时，使用Apache httpClient客户端访问返回结果中文乱码。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;初次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;检查HttpClient请求Content-type为UTF-8，排除客户端编码问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;再次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;查看本地tomcat编码为默认编码，服务器tomcat编码为UTF-8编码。怀疑是tomcat编码问题导致的，&#xA;修改本地tomcat编码为UTF-8，测试无乱码，排除tomcat编码问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;第三次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;因为客户端和服务器编码都没有问题，怀疑是接口输出数据有问题。添加日志记录输出结果，发现数据无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;怀疑是spring mvc 视图返回json字符串时编码有问题。百度一下发现spring mvc确实存在视图返回json字符串时使用的是iso-8859-1编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;测试之，使用response out流输出json字符串，结果无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;确定问题和spring mvc返回json数据编码导致。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;暂时使用输出流直接输出json字符串。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后续再测试网上提供的其他解决方案。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>post请求执行window open</title>
      <link>http://sakyawang.github.io/javascript/post%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8Cwindow-open/</link>
      <pubDate>2015-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般在html中打开新页面都是直接使用window.open(url)，打开新的页面是get请求，如果url有参数的话URL就会很长，在浏览器上会有参数显示。这里使用post请求可以避免该问题。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;创建一个form表单method为post方式：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;&amp;quot; method=&amp;quot;post&amp;quot; name=&amp;quot;targetForm&amp;quot; id=&amp;quot;targetForm&amp;quot; target=&amp;quot;targetForm&amp;quot; onsubmit=&amp;quot;openWindow(&#39;targetForm&#39;);&amp;quot;&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;name1&amp;quot; id=&amp;quot;id1&amp;quot;/&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;name2&amp;quot; id=&amp;quot;id2&amp;quot;/&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加onsubmit事件，执行openWindow（），具体js函数如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;function openWindow(name){    &#xA;    window.open(&#39;about:blank&#39;,name);     &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关键点是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;onsubmit=&amp;quot;openWindow(&#39;targetForm&#39;);&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;中参数要是form表单的名字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后在操作的时候触发表单的提交事件：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$(&amp;ldquo;#targetForm&amp;rdquo;).submit();&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>java des加密实践</title>
      <link>http://sakyawang.github.io/java/java-des%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>2015-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;工作中数据加密是C++实现的des加密，业务方是java语言。现在需要使用java对C++加密的内容进行解密。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;思路：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据C++的des加密算法实现，使用java进行逆向处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import javax.crypto.Cipher;&#xA;import javax.crypto.SecretKey;&#xA;import javax.crypto.spec.SecretKeySpec;&#xA;&#xA;public class DESUtil {&#xA;&#xA;    private static final String Key = &amp;quot;d4odQA#5&amp;quot;;&#xA;    private static final String Algorithm = &amp;quot;DES&amp;quot;;  //定义 加密算法,可用 DES,DESede,Blowfish&#xA;&#xA;    // 加密字符串&#xA;    public static String encryptMode(String src) {&#xA;        String hexStr = &amp;quot;&amp;quot;;&#xA;        try {&#xA;            Cipher c1 = Cipher.getInstance(&amp;quot;DES/ECB/NoPadding&amp;quot;);&#xA;            SecretKey key = new SecretKeySpec(Key.getBytes(), Algorithm);//生成加密解密需要的Key&#xA;            c1.init(Cipher.ENCRYPT_MODE, key);&#xA;            byte[] bytes = c1.doFinal(getByte(src));&#xA;            hexStr = bytesToHexString(bytes);&#xA;        } catch (java.security.NoSuchAlgorithmException e1) {&#xA;            e1.printStackTrace();&#xA;        } catch (javax.crypto.NoSuchPaddingException e2) {&#xA;            e2.printStackTrace();&#xA;        } catch (java.lang.Exception e3) {&#xA;            e3.printStackTrace();&#xA;        }&#xA;        return hexStr;&#xA;    }&#xA;&#xA;    // 解密字符串&#xA;    public static String decryptMode(String hexStr) {&#xA;        String src = &amp;quot;&amp;quot;;&#xA;        try {&#xA;            Cipher c1 = Cipher.getInstance(&amp;quot;DES/ECB/NoPadding&amp;quot;);&#xA;            SecretKey deskey = new SecretKeySpec(Key.getBytes(), Algorithm);//生成加密解密需要的Key&#xA;            c1.init(Cipher.DECRYPT_MODE , deskey);&#xA;            byte[] bytes = c1.doFinal(hexString2Bytes(hexStr));&#xA;            src = new String(bytes).trim();&#xA;        } catch (java.security.NoSuchAlgorithmException e1) {&#xA;            e1.printStackTrace();&#xA;        } catch (javax.crypto.NoSuchPaddingException e2) {&#xA;            e2.printStackTrace();&#xA;        } catch (java.lang.Exception e3) {&#xA;            e3.printStackTrace();&#xA;        }&#xA;        return src;&#xA;    }&#xA;&#xA;    public static String bytesToHexString(byte[] digestByte) {&#xA;        byte[] rtChar = new byte[digestByte.length * 2];&#xA;        for (int i = 0; i &amp;lt; digestByte.length; i++) {&#xA;            byte b1 = (byte) (digestByte[i] &amp;gt;&amp;gt; 4 &amp;amp; 0x0f);&#xA;            byte b2 = (byte) (digestByte[i] &amp;amp; 0x0f);&#xA;            rtChar[i * 2] = (byte) (b1 &amp;lt; 10 ? b1 + 48 : b1 + 55);&#xA;            rtChar[i * 2 + 1] = (byte) (b2 &amp;lt; 10 ? b2 + 48 : b2 + 55);&#xA;        }&#xA;        return new String(rtChar).toLowerCase();&#xA;    }&#xA;&#xA;    public static byte[] getByte(String szSrc){&#xA;&#xA;        int length = szSrc.length();&#xA;        int a = length % 8;&#xA;        int b = length / 8;&#xA;        int len = 0;&#xA;        if (a == 0){&#xA;            len = b*8;&#xA;        }else{&#xA;            len = (b+1)*8;&#xA;        }&#xA;        byte[] src = new byte[len];&#xA;        byte[] bytes = szSrc.getBytes();&#xA;        for (int i = 0;i&amp;lt;bytes.length;i++){&#xA;            src[i] = bytes[i];&#xA;        }&#xA;        return src;&#xA;    }&#xA;&#xA;    public static byte[] hexString2Bytes(String src)&#xA;    {&#xA;        int len = src.length();&#xA;        byte[] ret = new byte[len/2];&#xA;        byte[] tmp = src.getBytes();&#xA;        for(int i=0; i&amp;lt;len/2; ++i )&#xA;        {&#xA;            ret[i] = uniteBytes(tmp[i*2], tmp[i*2+1]);&#xA;        }&#xA;        return ret;&#xA;    }&#xA;&#xA;    private static byte uniteBytes(byte src0, byte src1) {&#xA;        byte _b0 = Byte.decode(&amp;quot;0x&amp;quot; + new String(new byte[]{src0})).byteValue();&#xA;        _b0 = (byte) (_b0 &amp;lt;&amp;lt; 4);&#xA;        byte _b1 = Byte.decode(&amp;quot;0x&amp;quot; + new String(new byte[]{src1})).byteValue();&#xA;        byte ret = (byte) (_b0 | _b1);&#xA;        return ret;&#xA;    }&#xA;&#xA;    public static void main(String[] args) {&#xA;        String szSrc = &amp;quot;root&amp;quot;;&#xA;        System.out.println(&amp;quot;加密前的字符串:&amp;quot; + szSrc);&#xA;        String s = encryptMode(szSrc);&#xA;        System.out.println(&amp;quot;加密后的字符串:&amp;quot; + s);&#xA;        String s1 = decryptMode(s);&#xA;        System.out.println(&amp;quot;解密后的字符串:&amp;quot; + s1);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>微信公众平台开发入门</title>
      <link>http://sakyawang.github.io/微信公众平台/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;因工作需要，要在微信公众平台上进行服务号的开发，现记录下开发流程。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、IDEA14、Jdk1.7、微信公众平台测试号、外网域名&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;搭建基础开发环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;搭建web项目使用最简单的Servlet做消息入口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建WeChatServlet 继承 HttpServlet&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在web.xml中配置sevlet的url路径&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;wechat&amp;lt;/servlet-name&amp;gt;&#xA;&amp;lt;servlet-class&amp;gt;cn.wh.wechat.WeChatServlet&amp;lt;/servlet-class&amp;gt;&#xA;&amp;lt;/servlet&amp;gt;&#xA;&amp;lt;servlet-mapping&amp;gt;&#xA;    &amp;lt;servlet-name&amp;gt;wechat&amp;lt;/servlet-name&amp;gt;&#xA;    &amp;lt;url-pattern&amp;gt;/wechat&amp;lt;/url-pattern&amp;gt;&#xA;&amp;lt;/servlet-mapping&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在微信公众平台申请管理测试号&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&#34;&gt;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登陆之后设置URL和token，URL就是外网域名/项目名/wechat,必须是80端口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置消息通道认证&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WeChatServlet的doGet方法如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protected void doGet(HttpServletRequest request,&#xA;        HttpServletResponse response) throws ServletException, IOException {&#xA;    String signature = request.getParameter(&amp;quot;signature&amp;quot;);// 微信加密签名&#xA;    String timestamp = request.getParameter(&amp;quot;timestamp&amp;quot;);// 时间戳&#xA;    String nonce = request.getParameter(&amp;quot;nonce&amp;quot;);// 随机数&#xA;    String echostr = request.getParameter(&amp;quot;echostr&amp;quot;);// 随机字符串&#xA;    if (StringUtils.isBlank(signature) || StringUtils.isBlank(timestamp)|| StringUtils.isBlank(nonce)) {&#xA;        Writer out = response.getWriter();&#xA;        out.write(&amp;quot;error...&amp;quot;);&#xA;        out.flush();&#xA;        out.close();&#xA;        return;&#xA;    }&#xA;    // 重写totring方法，得到三个参数的拼接字符串&#xA;    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(3) {&#xA;        private static final long serialVersionUID = 2621444383666420433L;&#xA;&#xA;        public String toString() {&#xA;            return this.get(0) + this.get(1) + this.get(2);&#xA;        }&#xA;    };&#xA;    list.add(TOKEN);&#xA;    list.add(timestamp);&#xA;    list.add(nonce);&#xA;    Collections.sort(list);// 排序&#xA;    String tmpStr = new MySecurity().encode(list.toString(),&#xA;            MySecurity.SHA_1);// SHA-1加密&#xA;    Writer out = response.getWriter();&#xA;    if (signature.equals(tmpStr)) {&#xA;        out.write(echostr);// 请求验证成功，返回随机码&#xA;    } else {&#xA;        out.write(&amp;quot;&amp;quot;);&#xA;    }&#xA;    out.flush();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在微信公众平台测试页面点击提交请求会到WeChatServlet的doGet方法，如果验证通过返回验证码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以上是在微信公众平台接入开发模式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后续会写一些开发中用到的消息处理机制。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>sublime text2 安装插件</title>
      <link>http://sakyawang.github.io/sublime/sublime-text2-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;sublime tex t2本身自带了编程语言雷插件，可以通过Preferences--&amp;gt;Browse Packages查看。&#xA;当然还有一些方便开发的插件需要单独安装。这里说一下sublime text2安装插件的操作流程。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、sublime text2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;打开sublime 使用ctrl+` 调出控制台窗口，输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import urllib2,os; &#xA;pf=&#39;Package Control.sublime-package&#39;; &#xA;ipp=sublime.installed_packages_path(); &#xA;os.makedirs(ipp) &#xA;if not &#xA;    os.path.exists(ipp) &#xA;else &#xA;    None; &#xA;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));&#xA;open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); &#xA;print &#39;Please restart Sublime Text to finish installation&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行完毕之后，重启sublime。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装插件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;ctrl+shift+P调出功能搜索框，输入 install 选择 install package，然后查找自己喜欢的插件 选择安装。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>mongodb安装配置</title>
      <link>http://sakyawang.github.io/mongodb/mongodb%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用mongoDB zip安装包安装配置mongodb。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;下载mongoDB安装包。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-3.0.4.zip&#34;&gt;https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-3.0.4.zip&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;解压缩安装包到 D盘根目录 D:\mongoDB&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mongoDB目录下创建data\db目录和data\log目录&#xA;分别用来安装db和日志文件，在log文件夹下创建一个日志文件MongoDB.log。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行cmd.exe进入dos命令界面，执行下列命令，启动MongoDB&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd d:\mongoDB\bin&#xA;d:\mongodb\bin&amp;gt;mongod -dbpath &amp;quot;d:\mongoDB\data\db&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果看到信息显示当前监听端口27017则表示启动成功。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;测试连接&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;打开一个cmd窗口，进入mongodb的bin目录，输入mongo或者mongo.exe，&#xA;出现 connect to test 等信息说明测试通过，此时我们已经进入了test这个数据库。&#xA;输入exit或者ctrl+C可退出。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当mongod.exe被关闭时，mongo.exe 就无法连接到数据库了。因此每次想使用mongodb数据库都要开启mongod.exe程序，所以比较麻烦，此时我们可以将MongoDB安装为windows服务。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行cmd，进入bin文件夹，执行下列命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;d:\mongoDB\bin&amp;gt;mongod --dbpath &amp;quot;d:\mongoDB\data\db&amp;quot; --logpath &amp;quot;d:\mongoDB\data\log\MongoDB.log&amp;quot; --install --serviceName &amp;quot;MongoDB&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;　这里MongoDB.log就是开始建立的日志文件，--serviceName &amp;ldquo;MongoDB&amp;rdquo; 设置服务名为MongoDB。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;　接着启动mongodb服务&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;d:\mongodb\bin&amp;gt;NET START MongoDB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>gor创建个人博客</title>
      <link>http://sakyawang.github.io/golang/gor%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、golang、git&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;下载安装gor&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;gor github&lt;/a&gt;&#xA;里面有gor的安装和使用说明。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里主要说一下使用中遇到的问题：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行 go install github.com/wendal/gor/gor 操作的时候&#xA;会报错：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;connot find package &amp;ldquo;github.com/howeyc/fsnotify&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;处理方案如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/howeyc/fsnotify&#34;&gt;https://github.com/howeyc/fsnotify&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下载zip包。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;解压缩zip包内容到$GOPATH/src/github.com/howeyc/fsnotify&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意fsnotify目录下就是文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后再执行 go install github.com/wendal/gor/gor&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;搭建github个人博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;参考 &lt;a href=&#34;http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.html&#34;&gt;http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先要有一个github个人账号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建public仓库，名字以username.github.com命名。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进入username.github.com仓库，选择右侧的setting。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在github Pages里面选择Launch automatic page generator按钮。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在新页面选择博客主题然后保存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;访问username.github.io即可看到个人主页。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;提交个人博客到github&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用git 命令行或者客户端clone username.github.com库到本地git库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把gor编译生成的compile文件加下的内容，添加更新到本地git库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提交更新到github。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;访问username.github.io查看更新。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（因为七牛认证还未通过，暂时无法提供图片外链，认证通过之后补充操作截图）&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>本地搭建golang开发学习环境</title>
      <link>http://sakyawang.github.io/golang/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAgolang%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</link>
      <pubDate>2015-07-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;由于工作原因要学习golang，根据golang推荐学习方法搭建本地A tour of GO环境，记录操作过程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;5&#34;&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;win7 64位&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;下载并安装golang&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.golangtc.com/download&#34;&gt;http://www.golangtc.com/download&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;exe文件install安装&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;配置go环境变量&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;环境变量添加GOROOT为GO的安装目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;环境变量添加GOPATH是GO的项目目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当使用go get 获取内容时保存在GOPATH下，相当于workspace。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/goenv.png&#34; alt=&#34;go环境变量配置&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装完成之后，cmd下执行go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/gocmd.png&#34; alt=&#34;go测试&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如图则安装配置成功&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装Mercurial&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mercurial 是一个跨平台的分布式版本控制软件。Mercurial主要由Python语言实现，不过也包含一个用C实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux。现在Mercurial已经被移植到Windows、Mac OS X 和大多数类Unix系统中。Mercurial主要由一个命令行程序组成，但现在也有了图形用户界面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你的系统中没有安装Mercurial，你就无法使用hg命令。&#xA; 下载：&lt;a href=&#34;https://mercurial.selenic.com/wiki/Download#Windows&#34;&gt;https://mercurial.selenic.com/wiki/Download#Windows&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装python2.7&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Mercurial依赖python2.7 ，需安装python2.7&#xA;下载：&lt;a href=&#34;https://www.python.org/downloads/release/python-2710/&#34;&gt;https://www.python.org/downloads/release/python-2710/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;install安装配置环境变量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装go-tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;墙外用户命令行下执行：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go get code.google.com/p/go-tour/gotour&lt;/p&gt;&#xA;&#xA;&lt;p&gt;墙内用户：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go get github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go install github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;成功的话会在，$GOPATH/bin目录下生成gotour.cn.exe文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果获取失败，可以在github：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhanming/go-tour-cn.git&#34;&gt;https://github.com/zhanming/go-tour-cn.git&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下载zip包文件。然后解压缩到GOPATH下面的src目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/tour.png&#34; alt=&#34;tour 目录结构&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;编译本地go tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go install github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在$GOPATH/src/github&lt;strong&gt;/&lt;/strong&gt;*/gotour.cn 目录下命令行执行 go build&#xA;生成gotour.cn.exe&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;运行go tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;cmd下运行gotour.cn.exe 然后在浏览器输入&lt;a href=&#34;http://127.0.0.1:3999&#34;&gt;http://127.0.0.1:3999&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>